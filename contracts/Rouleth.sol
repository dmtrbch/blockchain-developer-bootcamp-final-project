// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

/// @title Roulette Simulator
/// @author Dimitar Bochvarovski
/// @notice Gambler can bet if the number on the roulette is black or red
/// @dev Random number is generated using the Chainlink VRF
contract Rouleth is Ownable,ReentrancyGuard,VRFConsumerBase {

  enum BetColor {
    BLACK,
    RED
  }

  struct Bet {
    address gamblerAddress;
    BetColor betColor;
    uint256 ammount;
  }

  /// @notice Array with 37 items, that represents the numbers in European roulette (0-36).
  /// @dev Used as a helper to determine whether the generated random number is red or black
  bool[37] isNumberRed = [false, true, false, true, false, true, false, true, false, true, false, false, true, false, true, false, true, false, true, true, false, true, false, true, false, true, false, true, false, false, true, false, true, false, true, false, true];
  
  uint256 public constant ROULETTE_NUMBER_COUNT = 37;


  /// @dev ID for the VRF keypair that the Chainlink Oracle commits to. This is provided from Chainlink
  bytes32 internal keyHash;
  
  /// @dev Every time random number is generated the contract must pay fee for the service in LINK
  /// @dev Minimum LINK price for VRF service
  uint256 internal fee;
  
  /// @notice Ammount of ETH held by the Casino
  uint256 public casinoReserve;

  /// @notice Ammount of ETH each gambler has in the Casino
  mapping(address => uint256) public casinoFunds;

  /// @dev Every time random number is requested, requestId is generated by the Chainlink Oracle and is mapped with the Bet details
  mapping(bytes32 => Bet) public gameRounds;



  /// @notice Emitted when a gambler places a bet
  /// @param requestId Request ID
  /// @param result Number on the Roulette, randomly generated number
  /// @dev Every time a bet is placed, a callback function fulfillRandomness which generates a rundom number is called, we are using this event to notify the frontend that the number has been generated
  event BetFinished(bytes32 indexed requestId, uint256 indexed result);



  modifier canDeposit {
    require(msg.value > 0, "Must send ETH to deposit funds in the casino!");
    _;
  }

  modifier canWithdraw(uint256 _funds){
    require(casinoFunds[msg.sender] >= _funds, "Requested withdrawal exceeds the available withdrawal ammount!");
    _;
  }

  modifier canPlaceBet(uint256 _betAmount){
    require(casinoFunds[msg.sender] >= _betAmount, "Not enough funds to place a bet!");
    _;
  }

  modifier hasFunds {
    require(casinoFunds[msg.sender] > 0, "You have no deposits in the casino!");
    _;
  }

  modifier hasReserves(uint256 _betAmount) {
    require(casinoReserve >= _betAmount*2, "Not enough funds in the Casino Reserve! Please lower your bets!");
    _;
  }



  /// @dev Chainlink VRF Coordinator address: 0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9
  /// @dev LINK token address:  0xa36085F69e2889c224210F603D836748e7dC0088
  constructor() 
    VRFConsumerBase(
      0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9,
      0xa36085F69e2889c224210F603D836748e7dC0088
    )
  {
    keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
    fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
  }
  


  /// @notice Deposit ETH to the Casino reserve
  /// @dev Only the owner of the contract can deposit funds
  function topUpCasinoReserve() external payable
    onlyOwner
    canDeposit {

      casinoReserve += msg.value;
  }

  /// @notice Gambler deposits funds to the Casino to be able to place bets
  function depositFunds() external payable
    canDeposit {

      casinoFunds[msg.sender] += msg.value;
  }

  /// @notice Gambler withdraws funds from his balance in the Casino to his MetaMask wallet
  /// @dev Reentrancy Guard is added to this function using Openzeppelin ReentrancyGuard.sol
  function withdrawFunds(uint256 funds) external
    hasFunds
    canWithdraw(funds)
    nonReentrant {

      casinoFunds[msg.sender] = casinoFunds[msg.sender] - funds;
      (bool success, ) = msg.sender.call{value: funds}("");
      require(success, "ETH withdrawal failed!");
  }

  /// @notice Ammount of ETH in the Casino for a particular gambler
  /// @param gambler MetaMask wallet address of the gambler
  /// @return Ammount of ETH that the gambler has in the Casino (in wei)
  function fundsOverview(address gambler) public view returns (uint256) {
    return casinoFunds[gambler];
  }

  /// @notice Place a bet in the Casino
  /// @param betColor Number of color that the gembler has bet on (black or white)
  /// @param betAmount Amount of ETH that the gambler has used for the bet (in wei)
  /// @return requestId which is used in the fulfillRandomness callback functions
  /// @dev Requests randomness from the Chainlink Oracle
  function placeBetOnColor(BetColor betColor, uint256 betAmount) public payable
    hasReserves(betAmount)
    canPlaceBet(betAmount)
    returns (bytes32 requestId) {
      require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");

      requestId = requestRandomness(keyHash, fee);
      Bet memory currentBet = Bet(msg.sender, betColor, betAmount);
      gameRounds[requestId] = currentBet;
  }

  // TODO: make possible for the gambler to bet on odd or even number
  /* function placeBetOnOddEven(bool oddOrEven, uint256 betAmount) public payable
    hasReserves(betAmount)
    canPlaceBet(betAmount) {
      require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");

      
  } */

  // TODO: make possible for the gambler to bet on specific number
  /*function placeBetOnNumber(uint256 number, uint256 betAmount) public payable
    hasReserves(betAmount)
    canPlaceBet(betAmount) {
      require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");

  } */

 
  /// @notice The function that generates the random number
  /// @param requestId The requestId for which the randomness is generated, we use it to track for which bet the random number is generated
  /// @param randomness The randomness generated from the oracle
  /// @dev We wait for this function to be called and act upon that, whether we need to withdraw funds from the casino reserve, and add them to the gembler funds or vice versa
  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
    
    uint256 roulethResult = randomness % ROULETTE_NUMBER_COUNT;

    Bet memory currentBet = gameRounds[requestId];

    bool isZero = roulethResult == 0;
    BetColor _betColor = isNumberRed[roulethResult] ? BetColor.RED : BetColor.BLACK;

    if(isZero) {
      casinoReserve += currentBet.ammount;
      casinoFunds[currentBet.gamblerAddress] -= currentBet.ammount;
    } 
    else if (_betColor == currentBet.betColor) {
      casinoReserve -= currentBet.ammount*2;
      casinoFunds[currentBet.gamblerAddress] += currentBet.ammount;
    } else {
      casinoReserve += currentBet.ammount;
      casinoFunds[currentBet.gamblerAddress] -= currentBet.ammount;
    }

    emit BetFinished(requestId, roulethResult);
  }
}